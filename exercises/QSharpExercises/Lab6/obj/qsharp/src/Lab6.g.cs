//------------------------------------------------------------------------------
// <auto-generated>                                                             
//     This code was generated by a tool.                                       
//     Changes to this file may cause incorrect behavior and will be lost if    
//     the code is regenerated.                                                 
// </auto-generated>                                                            
//------------------------------------------------------------------------------
#pragma warning disable 436
#pragma warning disable 162
#pragma warning disable 1591
using System;
using Microsoft.Quantum.Core;
using Microsoft.Quantum.Intrinsic;
using Microsoft.Quantum.Intrinsic.Interfaces;
using Microsoft.Quantum.Simulation.Core;

[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise1\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Empty\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":30,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"classicalBits\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":22},\"Item2\":{\"Line\":1,\"Column\":35}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"register\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":46},\"Item2\":{\"Line\":1,\"Column\":54}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you are given a classical bit array and a qubit\",\" register. Both are of unknown length, but they have the same length.\",\" Your goal is to apply the bitwise XOR operation in-place on the\",\" quantum register, using its own state and the classical bit array as\",\" the two input arguments, and using the register itself as the output.\",\" For example, if the classical bit array is 10110 and the qubit\",\" register is in the state |00101>, then this operation should put the\",\" qubit register into the state 10110 XOR 00101 = |10011>.\",\"\",\" # Input\",\" ## classicalBits\",\" A classical bit array that contains an unknown bit string of unknown\",\" length.\",\"\",\" ## register\",\" A qubit array in an unknown state, which has the same length as the\",\" classicalBits array.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise1\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":30,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"Documentation\":[]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsAdjoint\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"SimpleSet\",\"Fields\":[{\"Case\":\"Adjointable\"}]},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise1\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":30,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":2,\"Column\":8},\"Item2\":{\"Line\":2,\"Column\":11}},\"Documentation\":[\"automatically generated QsAdjoint specialization for Lab6.Exercise1\"]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise2\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Full\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":54,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"register\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":22},\"Item2\":{\"Line\":1,\"Column\":30}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"target\"]},\"Type\":{\"Case\":\"Qubit\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":1,\"Column\":42},\"Item2\":{\"Line\":1,\"Column\":48}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you must implement an oracle that checks if all of\",\" the provided qubits are in the |0> state. You are given a qubit\",\" register of unknown length in an unknown state, and a target qubit\",\" that is in the |1> state. Your goal is to phase-flip the target qubit\",\" if the register is in the state |0...0>.\",\"\",\" # Input\",\" ## register\",\" A register of unknown length in an unknown state.\",\"\",\" ## target\",\" The target qubit that you must phase-flip if the register is in the\",\" |0...0> state. The target qubit will be provided in the |1> state.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise2\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":54,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise3\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Empty\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":99,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"originalMessage\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":24}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"encryptedMessage\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":25}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"candidateEncryptionKey\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":9},\"Item2\":{\"Line\":4,\"Column\":31}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"target\"]},\"Type\":{\"Case\":\"Qubit\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":5,\"Column\":9},\"Item2\":{\"Line\":5,\"Column\":15}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you must implement an oracle that checks to see if a\",\" provided encryption key is correct. You are given an original message\",\" as a classical bit string and the message after it has been encrypted\",\" with an unknown encryption key. The encryption algorithm is a bitwise\",\" XOR. You are also given a qubit register which represents the\",\" encryption key being checked, and a target qubit. Your goal is to\",\" phase-flip the target qubit if the state of the qubit register\",\" corresponds to the encryption key that was used to encrypt the\",\" original message.\",\"\",\" # Input\",\" ## originalMessage\",\" A classical bitstring containing the original message that was\",\" encrypted.\",\"\",\" ## encryptedMessage\",\" A classical bitstring containing the original message after it was\",\" encrypted with a bitwise XOR algorithm.\",\"\",\" ## candidateEncryptionKey\",\" A quantum register containing the potential encryption key that is\",\" being checked by your oracle - think of it like a quantum version of\",\" the classical encryption key.\",\"\",\" ## target\",\" The qubit that you should phase-flip if the candidate key is the\",\" correct key - that is, if encrypting the original message with it\",\" produces the same bitstring as the encryptedMessage bitstring.\",\"\",\" # Remarks\",\" Obviously, bitwise XOR is a trivial example because you can just XOR\",\" the original message with the encrypted message to recover the\",\" encryption key. The point of this exercise is to show that this\",\" process can be done with any algorithm, including ones that are\",\" nontrivial like modern cryptographic cyphers (SHA256, AES, etc.). XOR\",\" is just used here because it's easy to implement, think of it as a\",\" proof-of-concept.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise3\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":99,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise4\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Opaque\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Full\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":149,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"oracle\"]},\"Type\":{\"Case\":\"Operation\",\"Fields\":[{\"Item1\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"Item2\":{\"Case\":\"UnitType\"}},{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":15}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"register\"]},\"Type\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":17}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"target\"]},\"Type\":{\"Case\":\"Qubit\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":4,\"Column\":9},\"Item2\":{\"Line\":4,\"Column\":15}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Operation\",\"Fields\":[{\"Item1\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"Item2\":{\"Case\":\"UnitType\"}},{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}]},{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"ReturnType\":{\"Case\":\"UnitType\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you must implement the repeated quantum iteration in\",\" Grover's algorithm, which consists of running the oracle and then the\",\" diffusion operator. You are given an oracle to run, a qubit register\",\" representing the input to the oracle, and a target qubit that the\",\" oracle can use for phase-flipping if provided with the correct input.\",\"\",\" # Input\",\" ## oracle\",\" A function object representing the oracle being used during the search\",\" to find the \\\"correct\\\" state. You can run it with the following syntax:\",\"     oracle(Register, Target);\",\"\",\" ## register\",\" A qubit register of unknown length and unknown state. This represents\",\" the input you should provide to the oracle.\",\"\",\" ## target\",\" A qubit in the |1> state. This represents a target you can use for any\",\" phase-flipping oracles.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise4\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":149,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"Documentation\":[]}")]
[assembly: CallableDeclaration("{\"Kind\":{\"Case\":\"Operation\"},\"QualifiedName\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise5\"},\"Attributes\":[{\"TypeId\":{\"Case\":\"Value\",\"Fields\":[{\"Namespace\":\"Microsoft.Quantum.Targeting\",\"Name\":\"RequiresCapability\",\"Range\":{\"Case\":\"Null\"}}]},\"TypeIdRange\":{\"Case\":\"Null\"},\"Argument\":{\"Item1\":{\"Case\":\"ValueTuple\",\"Fields\":[[{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Transparent\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Full\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},{\"Item1\":{\"Case\":\"StringLiteral\",\"Fields\":[\"Inferred automatically by the compiler.\",[]]},\"Item2\":[],\"Item3\":{\"Case\":\"String\"},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}}]]},\"Item2\":[],\"Item3\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"String\"},{\"Case\":\"String\"},{\"Case\":\"String\"}]]},\"Item4\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Item5\":{\"Case\":\"Null\"}},\"Offset\":{\"Item1\":0,\"Item2\":0},\"Comments\":{\"OpeningComments\":[],\"ClosingComments\":[]}}],\"Modifiers\":{\"Access\":{\"Case\":\"DefaultAccess\"}},\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":183,\"Item2\":4},\"SymbolRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"ArgumentTuple\":{\"Case\":\"QsTuple\",\"Fields\":[[{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"oracle\"]},\"Type\":{\"Case\":\"Operation\",\"Fields\":[{\"Item1\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"Item2\":{\"Case\":\"UnitType\"}},{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}]},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":2,\"Column\":9},\"Item2\":{\"Line\":2,\"Column\":15}}}]},{\"Case\":\"QsTupleItem\",\"Fields\":[{\"VariableName\":{\"Case\":\"ValidName\",\"Fields\":[\"numberOfQubits\"]},\"Type\":{\"Case\":\"Int\"},\"InferredInformation\":{\"IsMutable\":false,\"HasLocalQuantumDependency\":false},\"Position\":{\"Case\":\"Null\"},\"Range\":{\"Item1\":{\"Line\":3,\"Column\":9},\"Item2\":{\"Line\":3,\"Column\":23}}}]}]]},\"Signature\":{\"TypeParameters\":[],\"ArgumentType\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"Operation\",\"Fields\":[{\"Item1\":{\"Case\":\"TupleType\",\"Fields\":[[{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Qubit\"}]},{\"Case\":\"Qubit\"}]]},\"Item2\":{\"Case\":\"UnitType\"}},{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}]},{\"Case\":\"Int\"}]]},\"ReturnType\":{\"Case\":\"ArrayType\",\"Fields\":[{\"Case\":\"Bool\"}]},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}}},\"Documentation\":[\" # Summary\",\" In this exercise, you must implement Grover's quantum search\",\" algorithm. You have already implemented all of the pieces, so now you\",\" just need to put them all together. You are given an oracle which can\",\" correctly identify the \\\"correct\\\" answer to the problem being searched,\",\" and a number of qubits that it expects for its input register. Your\",\" goal is to use this information to run Grover's search and find the\",\" correct state.\",\"\",\" # Input\",\" ## oracle\",\" A phase-flipping operation that can identify the \\\"correct\\\" answer to a\",\" problem by giving it a negative amplitude.\",\"\",\" ## numberOfQubits\",\" The number of qubits that the oracle expects in its input register.\",\"\",\" # Output\",\" You must return a classical bit string (false for 0, true for 1) that\",\" represents the solution that the search algorithm found.\"]}")]
[assembly: SpecializationDeclaration("{\"Kind\":{\"Case\":\"QsBody\"},\"TypeArguments\":{\"Case\":\"Null\"},\"Information\":{\"Characteristics\":{\"Case\":\"EmptySet\"},\"InferredInformation\":{\"IsSelfAdjoint\":false,\"IsIntrinsic\":false}},\"Parent\":{\"Namespace\":\"Lab6\",\"Name\":\"Exercise5\"},\"Attributes\":[],\"SourceFile\":\"D:\\\\BWSI\\\\exercises\\\\exercises\\\\QSharpExercises\\\\Lab6\\\\Lab6.qs\",\"Position\":{\"Item1\":183,\"Item2\":4},\"HeaderRange\":{\"Item1\":{\"Line\":1,\"Column\":11},\"Item2\":{\"Line\":1,\"Column\":20}},\"Documentation\":[]}")]
#line hidden
namespace Lab6
{
    [SourceLocation("D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs", OperationFunctor.Body, 31, 55)]
    [SourceLocation("D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs", OperationFunctor.Adjoint, 31, 55)]
    public partial class Exercise1 : Adjointable<(IQArray<Boolean>,IQArray<Qubit>)>, ICallable
    {
        public Exercise1(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(IQArray<Boolean>,IQArray<Qubit>)>, IApplyData
        {
            public In((IQArray<Boolean>,IQArray<Qubit>) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return ((IApplyData)Data.Item2)?.Qubits;
                }
            }
        }

        String ICallable.Name => "Exercise1";
        String ICallable.FullName => "Lab6.Exercise1";
        protected ICallable Length__
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__X
        {
            get;
            set;
        }

        protected ICallable<QRange, QRange> RangeReverse__
        {
            get;
            set;
        }

        public override Func<(IQArray<Boolean>,IQArray<Qubit>), QVoid> __Body__ => (__in__) =>
        {
            var (classicalBits,register) = __in__;
#line 33 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            foreach (var i in new QRange(0L, (classicalBits.Length - 1L)))
#line hidden
            {
#line 34 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                if (classicalBits[i])
                {
#line 35 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                    Microsoft__Quantum__Intrinsic__X.Apply(register[i]);
                }
            }

#line hidden
            return QVoid.Instance;
        }

        ;
        public override Func<(IQArray<Boolean>,IQArray<Qubit>), QVoid> __AdjointBody__ => (__in__) =>
        {
            var (classicalBits,register) = __in__;
#line 31 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            foreach (var __qsVar0__i__ in RangeReverse__.Apply(new QRange(0L, (classicalBits.Length - 1L))))
#line hidden
            {
#line 31 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                if (classicalBits[__qsVar0__i__])
                {
#line 31 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                    Microsoft__Quantum__Intrinsic__X.Adjoint.Apply(register[__qsVar0__i__]);
                }
            }

#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Length__ = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Core.Length<>));
            this.Microsoft__Quantum__Intrinsic__X = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.X));
            this.RangeReverse__ = this.__Factory__.Get<ICallable<QRange, QRange>>(typeof(global::Microsoft.Quantum.Core.RangeReverse));
        }

        public override IApplyData __DataIn__((IQArray<Boolean>,IQArray<Qubit>) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, IQArray<Boolean> classicalBits, IQArray<Qubit> register)
        {
            return __m__.Run<Exercise1, (IQArray<Boolean>,IQArray<Qubit>), QVoid>((classicalBits, register));
        }
    }

    [SourceLocation("D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs", OperationFunctor.Body, 55, 100)]
    public partial class Exercise2 : Operation<(IQArray<Qubit>,Qubit), QVoid>, ICallable
    {
        public Exercise2(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(IQArray<Qubit>,Qubit)>, IApplyData
        {
            public In((IQArray<Qubit>,Qubit) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return Qubit.Concat(((IApplyData)Data.Item1)?.Qubits, ((IApplyData)Data.Item2)?.Qubits);
                }
            }
        }

        String ICallable.Name => "Exercise2";
        String ICallable.FullName => "Lab6.Exercise2";
        protected ICallable Microsoft__Quantum__Canon__ApplyToEach
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__X
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__Z
        {
            get;
            set;
        }

        public override Func<(IQArray<Qubit>,Qubit), QVoid> __Body__ => (__in__) =>
        {
            var (register,target) = __in__;
#line 56 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            Microsoft__Quantum__Canon__ApplyToEach.Apply((Microsoft__Quantum__Intrinsic__X, register));
#line 57 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            Microsoft__Quantum__Intrinsic__Z.Controlled.Apply((register, target));
#line 58 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            Microsoft__Quantum__Canon__ApplyToEach.Apply((Microsoft__Quantum__Intrinsic__X, register));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Canon__ApplyToEach = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Canon.ApplyToEach<>));
            this.Microsoft__Quantum__Intrinsic__X = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.X));
            this.Microsoft__Quantum__Intrinsic__Z = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.Z));
        }

        public override IApplyData __DataIn__((IQArray<Qubit>,Qubit) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, IQArray<Qubit> register, Qubit target)
        {
            return __m__.Run<Exercise2, (IQArray<Qubit>,Qubit), QVoid>((register, target));
        }
    }

    [SourceLocation("D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs", OperationFunctor.Body, 100, 150)]
    public partial class Exercise3 : Operation<(IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit), QVoid>, ICallable
    {
        public Exercise3(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit)>, IApplyData
        {
            public In((IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return Qubit.Concat(((IApplyData)Data.Item3)?.Qubits, ((IApplyData)Data.Item4)?.Qubits);
                }
            }
        }

        String ICallable.Name => "Exercise3";
        String ICallable.FullName => "Lab6.Exercise3";
        protected IAdjointable<(IQArray<Boolean>,IQArray<Qubit>)> Exercise1__
        {
            get;
            set;
        }

        protected ICallable Length__
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__X
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__Z
        {
            get;
            set;
        }

        public override Func<(IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit), QVoid> __Body__ => (__in__) =>
        {
            var (originalMessage,encryptedMessage,candidateEncryptionKey,target) = __in__;
#line 112 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            Exercise1__.Apply((originalMessage, candidateEncryptionKey));
#line 114 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            foreach (var i in new QRange(0L, (encryptedMessage.Length - 1L)))
#line hidden
            {
#line 115 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                if (!(encryptedMessage[i]))
                {
#line 116 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                    Microsoft__Quantum__Intrinsic__X.Apply(candidateEncryptionKey[i]);
                }
            }

#line 119 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            Microsoft__Quantum__Intrinsic__Z.Controlled.Apply((candidateEncryptionKey, target));
#line 120 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            foreach (var i in new QRange(0L, (encryptedMessage.Length - 1L)))
#line hidden
            {
#line 121 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                if (!(encryptedMessage[i]))
                {
#line 122 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                    Microsoft__Quantum__Intrinsic__X.Apply(candidateEncryptionKey[i]);
                }
            }

#line 126 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            Exercise1__.Adjoint.Apply((originalMessage, candidateEncryptionKey));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Exercise1__ = this.__Factory__.Get<IAdjointable<(IQArray<Boolean>,IQArray<Qubit>)>>(typeof(Exercise1));
            this.Length__ = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Core.Length<>));
            this.Microsoft__Quantum__Intrinsic__X = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.X));
            this.Microsoft__Quantum__Intrinsic__Z = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.Z));
        }

        public override IApplyData __DataIn__((IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, IQArray<Boolean> originalMessage, IQArray<Boolean> encryptedMessage, IQArray<Qubit> candidateEncryptionKey, Qubit target)
        {
            return __m__.Run<Exercise3, (IQArray<Boolean>,IQArray<Boolean>,IQArray<Qubit>,Qubit), QVoid>((originalMessage, encryptedMessage, candidateEncryptionKey, target));
        }
    }

    [SourceLocation("D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs", OperationFunctor.Body, 150, 184)]
    public partial class Exercise4 : Operation<(ICallable,IQArray<Qubit>,Qubit), QVoid>, ICallable
    {
        public Exercise4(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(ICallable,IQArray<Qubit>,Qubit)>, IApplyData
        {
            public In((ICallable,IQArray<Qubit>,Qubit) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return Qubit.Concat(((IApplyData)Data.Item1)?.Qubits, ((IApplyData)Data.Item2)?.Qubits, ((IApplyData)Data.Item3)?.Qubits);
                }
            }
        }

        String ICallable.Name => "Exercise4";
        String ICallable.FullName => "Lab6.Exercise4";
        protected ICallable Microsoft__Quantum__Canon__ApplyToEach
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__H
        {
            get;
            set;
        }

        protected ICallable<(IQArray<Qubit>,Qubit), QVoid> Exercise2__
        {
            get;
            set;
        }

        public override Func<(ICallable,IQArray<Qubit>,Qubit), QVoid> __Body__ => (__in__) =>
        {
            var (oracle,register,target) = __in__;
#line 156 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            oracle.Apply((register, target));
#line 157 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            Microsoft__Quantum__Canon__ApplyToEach.Apply((Microsoft__Quantum__Intrinsic__H, register));
#line 158 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            Exercise2__.Apply((register, target));
#line 159 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            Microsoft__Quantum__Canon__ApplyToEach.Apply((Microsoft__Quantum__Intrinsic__H, register));
#line hidden
            return QVoid.Instance;
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Canon__ApplyToEach = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Canon.ApplyToEach<>));
            this.Microsoft__Quantum__Intrinsic__H = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.H));
            this.Exercise2__ = this.__Factory__.Get<ICallable<(IQArray<Qubit>,Qubit), QVoid>>(typeof(Exercise2));
        }

        public override IApplyData __DataIn__((ICallable,IQArray<Qubit>,Qubit) data) => new In(data);
        public override IApplyData __DataOut__(QVoid data) => data;
        public static System.Threading.Tasks.Task<QVoid> Run(IOperationFactory __m__, ICallable oracle, IQArray<Qubit> register, Qubit target)
        {
            return __m__.Run<Exercise4, (ICallable,IQArray<Qubit>,Qubit), QVoid>((oracle, register, target));
        }
    }

    [SourceLocation("D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs", OperationFunctor.Body, 184, -1)]
    public partial class Exercise5 : Operation<(ICallable,Int64), IQArray<Boolean>>, ICallable
    {
        public Exercise5(IOperationFactory m) : base(m)
        {
        }

        public class In : QTuple<(ICallable,Int64)>, IApplyData
        {
            public In((ICallable,Int64) data) : base(data)
            {
            }

            System.Collections.Generic.IEnumerable<Qubit> IApplyData.Qubits
            {
                get
                {
                    return ((IApplyData)Data.Item1)?.Qubits;
                }
            }
        }

        String ICallable.Name => "Exercise5";
        String ICallable.FullName => "Lab6.Exercise5";
        protected ICallable<Double, Int64> Microsoft__Quantum__Math__Round
        {
            get;
            set;
        }

        protected ICallable<(Double,Double), Double> Microsoft__Quantum__Math__PowD
        {
            get;
            set;
        }

        protected ICallable<Int64, Double> Microsoft__Quantum__Convert__IntAsDouble
        {
            get;
            set;
        }

        protected Allocate Allocate__
        {
            get;
            set;
        }

        protected Release Release__
        {
            get;
            set;
        }

        protected ICallable Microsoft__Quantum__Canon__ApplyToEach
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__H
        {
            get;
            set;
        }

        protected IUnitary<Qubit> Microsoft__Quantum__Intrinsic__X
        {
            get;
            set;
        }

        protected ICallable<(ICallable,IQArray<Qubit>,Qubit), QVoid> Exercise4__
        {
            get;
            set;
        }

        protected ICallable<Qubit, Result> Microsoft__Quantum__Intrinsic__M
        {
            get;
            set;
        }

        protected ICallable<IQArray<Qubit>, QVoid> ResetAll__
        {
            get;
            set;
        }

        public override Func<(ICallable,Int64), IQArray<Boolean>> __Body__ => (__in__) =>
        {
            var (oracle,numberOfQubits) = __in__;
#line 191 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
            var iterations = Microsoft__Quantum__Math__Round.Apply(Microsoft__Quantum__Math__PowD.Apply((2D, (Microsoft__Quantum__Convert__IntAsDouble.Apply(numberOfQubits) / 2D))));
#line hidden
            {
#line 193 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                var register = Allocate__.Apply(numberOfQubits);
#line hidden
                bool __arg1__ = true;
                try
                {
#line hidden
                    {
#line 194 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                        var target = Allocate__.Apply();
#line hidden
                        bool __arg2__ = true;
                        try
                        {
#line 195 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                            Microsoft__Quantum__Canon__ApplyToEach.Apply((Microsoft__Quantum__Intrinsic__H, register));
#line 196 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                            Microsoft__Quantum__Intrinsic__X.Apply(target);
#line 198 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                            foreach (var i in new QRange(1L, iterations))
#line hidden
                            {
#line 199 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                                Exercise4__.Apply((oracle, register, target));
                            }

#line 202 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                            var output = new QArray<Boolean>();
#line 203 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                            foreach (var qubit in register)
#line hidden
                            {
#line 204 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                                output = QArray<Boolean>.Add(output, new QArray<Boolean>((Microsoft__Quantum__Intrinsic__M.Apply(qubit) == Result.One)));
                            }

#line 207 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                            ResetAll__.Apply(QArray<Qubit>.Add(register, new QArray<Qubit>(target)));
#line 208 "D:\\BWSI\\exercises\\exercises\\QSharpExercises\\Lab6\\Lab6.qs"
                            return output;
                        }
#line hidden
                        catch
                        {
                            __arg2__ = false;
                            throw;
                        }
#line hidden
                        finally
                        {
                            if (__arg2__)
                            {
#line hidden
                                Release__.Apply(target);
                            }
                        }
                    }
                }
#line hidden
                catch
                {
                    __arg1__ = false;
                    throw;
                }
#line hidden
                finally
                {
                    if (__arg1__)
                    {
#line hidden
                        Release__.Apply(register);
                    }
                }
            }
        }

        ;
        public override void __Init__()
        {
            this.Microsoft__Quantum__Math__Round = this.__Factory__.Get<ICallable<Double, Int64>>(typeof(global::Microsoft.Quantum.Math.Round));
            this.Microsoft__Quantum__Math__PowD = this.__Factory__.Get<ICallable<(Double,Double), Double>>(typeof(global::Microsoft.Quantum.Math.PowD));
            this.Microsoft__Quantum__Convert__IntAsDouble = this.__Factory__.Get<ICallable<Int64, Double>>(typeof(global::Microsoft.Quantum.Convert.IntAsDouble));
            this.Allocate__ = this.__Factory__.Get<Allocate>(typeof(global::Microsoft.Quantum.Intrinsic.Allocate));
            this.Release__ = this.__Factory__.Get<Release>(typeof(global::Microsoft.Quantum.Intrinsic.Release));
            this.Microsoft__Quantum__Canon__ApplyToEach = this.__Factory__.Get<ICallable>(typeof(global::Microsoft.Quantum.Canon.ApplyToEach<>));
            this.Microsoft__Quantum__Intrinsic__H = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.H));
            this.Microsoft__Quantum__Intrinsic__X = this.__Factory__.Get<IUnitary<Qubit>>(typeof(global::Microsoft.Quantum.Intrinsic.X));
            this.Exercise4__ = this.__Factory__.Get<ICallable<(ICallable,IQArray<Qubit>,Qubit), QVoid>>(typeof(Exercise4));
            this.Microsoft__Quantum__Intrinsic__M = this.__Factory__.Get<ICallable<Qubit, Result>>(typeof(global::Microsoft.Quantum.Intrinsic.M));
            this.ResetAll__ = this.__Factory__.Get<ICallable<IQArray<Qubit>, QVoid>>(typeof(global::Microsoft.Quantum.Intrinsic.ResetAll));
        }

        public override IApplyData __DataIn__((ICallable,Int64) data) => new In(data);
        public override IApplyData __DataOut__(IQArray<Boolean> data) => data;
        public static System.Threading.Tasks.Task<IQArray<Boolean>> Run(IOperationFactory __m__, ICallable oracle, Int64 numberOfQubits)
        {
            return __m__.Run<Exercise5, (ICallable,Int64), IQArray<Boolean>>((oracle, numberOfQubits));
        }
    }
}